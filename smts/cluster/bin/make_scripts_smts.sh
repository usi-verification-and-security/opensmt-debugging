#!/bin/bash



if [[ $# -ne 7 ]]; then
    echo "Usage: $0 <smts> <lemma_sharing> <partitioning> <script-dir> <output-dir> <config> <benchmark path>";
    exit 1;
fi

smts_server=$1; shift
lemma_sharing=$1; shift
if [[ ${lemma_sharing} == true ]]; then
    lemma='-l'
else
    lemma=''
fi

partitioning=$1; shift
if [[ ${partitioning} == true ]]; then
    partition='-p'
else
    partition=''
fi

script_dir=$1; shift
#work under linux
out_dir=`readlink -e $1`; shift

#work under mac
#out_dir=$(cd $(basename $1); pwd) shift

config=$1; shift
bmpath=$1; shift

counter=0

# How many SMTS to run in the node (three smts_server on different ports, each 3 solver and one lemmas server)
# Total process = 3 smts_server + 9 solver_client + 3 lemma_server
n_smts=3

# Starting port
port=3000

files=()
for file in $(find $bmpath -name '*.smt2.bz2'); do
    files+=( ${file} )
done

set -- "${files[@]}"

r=0
while (( $# )); do
    scriptfile=$(printf "${script_dir}/%04d.sh" ${r})
    outfilebase=$(printf "${out_dir}/%04d" ${r})
    ex=$1;
    echo "generating $scriptfile"
    cat << __EOF__ > $scriptfile
#!/bin/bash
## Generated by $0
## From $ex
#SBATCH --time=00:30:00
#SBATCH --nodes=1
#SBATCH --exclusive
#SBATCH --mem=0
#SBATCH --output=$outfilebase.out
#SBATCH --error=$outfilebase.err

smts_time=$outfilebase
output=$outfilebase

config=${config}
script=${smts_server}

__EOF__

    for ((i=0; i < $n_smts; i++)); do
        if [[ $# == 0 ]]; then
            break;
        fi
        ex=$1; shift
        ex_id=$(echo $ex |sed 's!^'$bmpath'[/]*!!g')
        ex_printable=$(echo $ex_id |tr '/' '_')
        cat << __EOF__ >> $scriptfile
 (
  echo $ex_id;
  TMPDIR=\$(mktemp -d)
  trap "rm -rf \$TMPDIR" EXIT
  inp=\$TMPDIR/\$(basename \${script})-`basename $ex_printable .bz2`;
  bunzip2 -c $ex > \${inp};
  sh -c "/usr/bin/time -o \${smts_time}.${i}.time -f 'user: %U system: %S wall: %e CPU: %PCPU' python3 \$script $lemma $partition -o3 -pn $((port+i)) -fp \$inp" || true; rm \${inp};
 ) > \$output.${i}.out 2> \$output.${i}.err;
 out_path=\$output.${i}
 grep '^;' \$out_path.out > /dev/null && (cat \$out_path.out >> \$out_path.err; echo $ex'\n'error  > \$out_path.out) &
__EOF__
    done
    echo "wait" >> $scriptfile
    i=$((i+1))
    chmod +x $scriptfile
    r=$((r+1))
done
